# 基于令牌桶的分布式限流器示例

基于 Guava 的限流器实现（基于`SmoothBursty`算法版），
通过其可透支令牌的特性，实现了请求队列的缓冲功能，即令牌桶在令牌不足时，如果透支令牌的恢复时间不超过设定的超时时间，则允许透支令牌，并使请求休眠到当次申请的令牌恢复再放行。
代码主要修改了令牌桶状态的存储逻辑，把令牌桶的状态存储到了 Redis 中，从而实现了一个简易的分布式令牌桶。

Redis 的连接采用了 Redisson，主要考虑到为了方便使用了 Redisson 的分布式锁。
可根据需要修改为其他（Jedis、RedisTemplate 等），分布式锁也可换成其他实现。

[ratelimiter-distributed](ratelimiter-distributed)模块是具体的实现代码。

[start](start)模块则是对于不同限流器的测试，包括了:

- `ratelimiter-distributed`的实现
- Guava 的单机版实现
- Redisson 的实现

## 存在的问题

1. 冷启动问题：当桶内令牌数较多(尤其是满令牌时)，对于突发请求会出现实际一秒内发出的令牌数量多于期望的情况。
   例如：创建一个限流器，每秒发送 5 个令牌，桶的大小也设置为 5，等待令牌桶装满 5 个令牌，假设每个请求申请一个令牌，在极短的时间内先来了
   5 个请求，此时令牌桶中的 5 个令牌会全部发出去，假设处理折 5 个请求花了 50ms，则 1 秒中还剩下 950ms，这段时间最多还能生成
   4 个令牌，因此这 1 秒中最多能发出去 9 个令牌。
2. 在实际测试的情况下，连接远程的 Redis，并且代码运行速度稍微慢一些的话，就会出现这种情况。比如在令牌桶满令牌的情况下来了 10
   个请求，光是把桶里的 5 个令牌发出去就会花费超过 200ms，此时已经新生成了一个令牌，假设超时时间还允许透支 3 个令牌，则一秒内实际发出了
   5+1+3=9 个令牌。

对于这种情况，有两种解决方法：

1. 减小令牌桶的容量，令牌生成的速度不变
2. 改进令牌桶算法，参考 Guava 的`SmoothWarmingUp`实现，增加从桶里拿走已经生成的令牌的代价。

> 目前有问题的应该是桶在满的时候拿走令牌的代价，而不只是刚启动后的时刻
